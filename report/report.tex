\documentclass[11pt]{report}
\title{Predator Prey Model}
\author{Names Here}
\date{November 2011}

\usepackage{tikz}
\usepackage{verbatim} 
\usepackage{pict2e}
\usepackage[pdftex]{hyperref}
%%%%% Remove URL link boxes %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}
\usepackage{times}

%%%%% Code Constraints %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
 \usepackage{courier}
%\lstset{
\lstset{columns=fullflexible,
language=Java,
%captionpos=b,
basicstyle=\footnotesize,
keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
identifierstyle=\ttfamily,
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
showstringspaces=false,
%basicstyle=\small,
numberstyle=\footnotesize,
numbers=left,
stepnumber=1,
numbersep=5pt,
tabsize=1,
breaklines=true,
%prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
breakatwhitespace=false,
aboveskip={1.5\baselineskip},
columns=fixed,
%upquote=true,
extendedchars=true,
%frame=bottomline,
inputencoding=utf8
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\usetikzlibrary{shapes,arrows}


\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']

\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}

% i just wrote this to get the report started - feel free to change or add to it

In this task we worked as a group to implement a 2D, sequential predator-prey algorithm with spatial diffusion
in Java. We tried to design the program in such a way as to take advantage of Java's object-orientated, modular nature. 
Due to the large size of our group we also decided to develop a GUI for the program, although the code was designed 
in such a way as to be usable from the command line as well. -----is it?-----\newline{}

There is always some compromise between readability and performance in coding, and we tried to keep this balance in mind
when designing our code. We made best use of class structure whilst still keeping our implementation of the given 
algorithm as efficient as possible.\newline{}

The predator prey algorithm implemented in this project crudely models the interaction between population densities of different animals, specifically Hares and Pumas. Each population has a self-interaction coefficient (birth for Hares, death for Pumas) and a coefficient describing how it interacts with other species' populations. \newline{}

These populations exist on a `world' consisting of land and water, and are also able to diffuse across land squares with a rate determined by a diffusion coefficient. Thus, each population has N+1 coefficients which determine it's behaviour, where N is the number of animals.

\chapter{Model} %dmitry

$H_{ij}^{new}=H_{ij}^{old} + {\Delta}t(C_{1}H_{ij}^{old}+C_{2}H_{ij}^{old}P_{ij}^{old} + l(H_{i+1j}^{old} + H_{i-1j}^{old} + H_{ij+1}^{old} + H_{ij-1}^{old}-H_{ij}^{old}))$


\vspace{30 mm}

\noindent for k=1:NumberOfAnimals\newline{}
if (k=ThisAnimal) then\newline{}
$N_{k}^{new}=N_{k}^{old} + {\Delta}tC_{k}(k)N_{k}^{old}$\newline{}
else\newline{}
$N_{k}^{new}=N_{k}^{old} + {\Delta}tC_{k}(k)N_{k}^{old}N_{ThisAnimal}^{old}$\newline{}
end if\newline{}
end

where

\[ C_{Hare} = \left( \begin{array}{cc}
H & PH \end{array} \right)\]    


\chapter{Design \& Implementation}
   \section{Code}
      \subsection{Structure} %simon (dmitry to make flowchart)
      \subsection{Algorithm} %matt
      \subsection{Input/Output} %milena
      
          
       
           % Here is some stuff about input and output. Not finished yet. Still needs some things to be added (or removed). Feel free to change it! 
      
      Computers cannot deal with continuous data; therefore, when modelling any kind of a system, discrete approximations must be used instead. This means that to see, for example, how a particular system evolves in time one needs to represent it by a sequence of events occurring one after another and separated by discrete time steps. 
      %The system considered in this project is a "world" or landscape consisting of land and water, the former being inhabited by a population of pumas (predators) and hares (prey).
      \newline{}
      In our model the "world", or landscape, is represented by a rectangular grid of alterable dimensions $N \times N$, where $N$ can be as large as 2000.
      We designed the code in a way such that it can read in an ASCII file that contains a set of numbers, those being either 0 or 1 and representing water and land, respectively, parses them and stores in a two-dimensional array. This means that the code can be used to model landscapes of different sizes with various distributions of land and water.
      \newline{}
      The boundary conditions are assigned to the model by setting the values for density of both, pumas and hares, to 0 at the edges of the grid.      
      \newline{}
      The initial values for the densities of pumas and hares are chosen randomly from a range of numbers between ******dMin and dMax ****** and distributed across the land cells. All these tasks are implemented in methods within the InOut class.
      The initial values for parameters that appear in the partial differential equations governing the evolution of the system with time can be set up by the user, who will be able to interact with the program by means of Graphical User Interface (GUI). Specifically, it is allowed for the user to initialise the values for the birth, death and diffusion rates of both types of animals as well as the time step ($dt$), which controls how often the system is updated with new data.  The user can also control the frequency of creating the output files, by choosing a value for the parameter $T$ in the GUI window. The output gets created every $T$ time steps. We have also included an optional "range" feature which allows the user to set a range of initial values for all the differential coefficients and an increment. In this case the code will run several times creating separate outputs for every simulation. 
      \newline{}
      Alternatively, the user can execute the code directly from within the terminal using the command line ******list of arguments or a file??*******. In the next section we talk about the GUI in more detail. 
      \newline{}
      \newline{}
      
      The methods responsible for creating the output are included in the Output class. Depending on the user's preference, the code will create one output directory (for single initial values) or a number of such directories (for the range of initial values), i.e. one for each run. In both cases the user will be able to view the distribution of both populations across the landscape every $T$ time steps. The form of the output is a number of *.ppm files which can be viewed as images, or "maps", similar to these showed in the ****FIGURE******.
      \newline{}
      % We could put one of the images here. or two maybe, one for pumas and one for hares?
      \newline{}
      The number of the *.ppm files created depends on the initial parameters specified by the user, $dt$ and $T$. To maximise the level of output clarity we decided to make separate landscape "maps" for each type of animal, here pumas and hares. In each "map" the pixels corresponding to water cells are shown in blue, while the land cells are white. The variation in density of pumas/hares across the land cells is represented by different shades of grey, with black colour corresponding to the maximum value. 
      \newline{}
      For each type of animal, every $T$ time steps, the code also calculates the mean population density and writes it along with the corresponding time into a file. 
      

      
      	
      
      
      \subsection{GUI} %dmitry
   
   \section{Tools}
      \subsection{SVN} %matt
      \subsection{Makefile} %tom
      \subsection{Unit Testing} %jorge
      Every class of the project form a functional unit according to the design elaborated at the beginning of the \newline{}
  has been tested using the Java JUnit framework \newline{}
The libraries necessary to the tests are thus accessed from the test cases using Java import statements and extending the TestCase superclass in the class declaration:

\begin{lstlisting}[language=Java,caption= Test case headers]
import org.junit.Before;
import org.junit.Test;
import junit.framework.TestCase;

public class TestAnimal extends TestCase {
...
\end{lstlisting}

Then the test cases, for each class, follow the normal directives in use for Unit testing with JUnit. The most relevant methods were submitted to thorough tests, where their properties, return values and correct functioning were evaluated by comparing the actual results they provide with the expected ones. These procedures were implemented by test methods in each test case using the format required by the JUnit standards. 

Every test case included a setup() method that builds the initial object and its different parameters. Directives like @Before and @Test for every method declaration were thus inserted in the code were appropriate. The functioning of a method is then assessed comparing the expected results with the actual ones with JUnit testing methods such as AssertEquals(), AssertNotNull(), etc.

\begin{lstlisting}[language=Java,caption= Use of JUnit directives in test cases]
@Before
public void setUp() {
    ...
    testAnimal = new Animal(numbAnimals);
    testAnimal.setName("Puma");
    testAnimal.setDiffCo(diffCoIn);
    ...
@Test
public void testAnimal() {
    assertNotNull(testAnimal);
    assertNotNull(testAnimal2);
} 
...
\end{lstlisting}

\chapter{Performance Analysis}
   \section{Testing} %chen+tom
   
   Tests were preformed in order to profile the code's performance and scalability. The unix \emph{time} command was 
   used to time the code runs, with `user' and `system' time being summed to find the total computation time.\newline{}
   
   The relationship between total computation time per cell and the number of cells was measured in order to quantify the overhead
   needed by the code (see Figure \ref{overhead}). We found that, below a grid size of $\sim$100 by 100, overhead became important, whereas at 
   larger grid sizes the computation time scaled linearly with the total number of cells. Any scaling worse than linear (such as 
   total computation time being proportional to the NumberOfCells$^{1.2}$ would be a huge (and unnecessary) inefficiency, especially with larger grids.\newline{}
   
   Some overhead is inevitable in any code, but the amount of effort put into simplifying a problem (such as creating arrays of neighbours)
   should depend on the expected size of the problem. Our code could probably have had less overhead, allowing it to run faster with smaller grid sizes,
   but this would likely led to it having a worse (linear) scaling with cell number.
   
   
   
   \section{Analysis} %tom+chen
   
   \begin{figure}[h]
   
   \input{figs/overhead}
   \caption{\label{overhead}This is a graph of total time spent on each cell, which shows that overheads such as array initialisation
   and output (i.e. things not directly involved in the simulation) take up a significant fraction of computation
   time with grids smaller than $\sim$100 by 100.}
   \end{figure}

  




\chapter{Conclusions} %everyone

   \begin{figure}[h]
   
   \input{figs/density}
   \caption{Population density vs. time for Hares and Pumas. This periodic behaviour is typical of predator-prey interactions.}
   \end{figure}

\chapter{Group Evaluation} %everyone

\end{document}
