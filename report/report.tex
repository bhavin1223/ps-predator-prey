\documentclass[12pt]{report}
\title{Predator Prey Model}
\author{Names Here}
\date{November 2011}

\usepackage{tikz}
\usepackage{verbatim} 
\usepackage{pict2e}
\usepackage[pdftex]{hyperref}

\begin{document}

\usetikzlibrary{shapes,arrows}


\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']

\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}

% i just wrote this to get the report started - feel free to change or add to it

In this task we worked as a group to implement a 2D, sequential predator-prey algorithm with spatial diffusion
in Java. We tried to design the program in such a way as to take advantage of Java's object-orientated, modular nature. 
Due to the large size of our group we also decided to develop a GUI for the program, although the code was designed 
in such a way as to be usable from the command line as well. -----is it?-----\newline{}

There is always some compromise between readability and performance in coding, and we tried to keep this balance in mind
when designing our code. We made best use of class structure whilst still keeping our implementation of the given 
algorithm as efficient as possible.\newline{}

The predator prey algorithm implemented in this project crudely models the interaction between population densities of different animals, specifically Hares and Pumas. Each population has a self-interaction coefficient (birth for Hares, death for Pumas) and a coefficient describing how it interacts with other species' populations. \newline{}

These populations exist on a `world' consisting of land and water, and are also able to diffuse across land squares with a rate determined by a diffusion coeffient. Thus, each population has N+1 coefficients which determine it's behaviour, where N is the number of animals.

\chapter{Model} %dmitry

$H_{ij}^{new}=H_{ij}^{old} + {\Delta}t(C_{1}H_{ij}^{old}+C_{2}H_{ij}^{old}P_{ij}^{old} + l(H_{i+1j}^{old} + H_{i-1j}^{old} + H_{ij+1}^{old} + H_{ij-1}^{old}-H_{ij}^{old}))$


\vspace{30 mm}

\noindent for k=1:NumberOfAnimals\newline{}
if (k=ThisAnimal) then\newline{}
$N_{k}^{new}=N_{k}^{old} + {\Delta}tC_{k}(k)N_{k}^{old}$\newline{}
else\newline{}
$N_{k}^{new}=N_{k}^{old} + {\Delta}tC_{k}(k)N_{k}^{old}N_{ThisAnimal}^{old}$\newline{}
end if\newline{}
end

where

\[ C_{Hare} = \left( \begin{array}{cc}
H & PH \end{array} \right)\]    


\chapter{Design \& Implementation}
   \section{Code}
      \subsection{Structure} %simon (dmitry to make flowchart)
      \subsection{Algorithm} %matt
      \subsection{Input/Output} %milena
      \subsection{GUI} %dmitry
   
   \section{Tools}
      \subsection{SVN} %matt
      \subsection{Makefile} %tom
      \subsection{Unit Testing} %jorge

\chapter{Performance Analysis}
   \section{Testing} %chen+tom
   
   Tests were preformed in order to profile the code's performance and scalability. The unix {\emph time} command was 
   used to time the code runs, with `user' and `system' time being summed to find the total computation time.\newline{}
   
   The relationship between total computation time per cell and the number of cells was measured in order to quantify the overhead
   needed by the code (see Figure \ref{overhead}). We found that, below a grid size of $\sim$100 by 100, overhead became important, whereas at 
   larger grid sizes the computation time scaled linearly with the total number of cells. Any scaling worse than linear (such as 
   total computation time being proportional to the NumberOfCells$^{1.2}$ would be a huge (and unecessary) inefficieny, especially with larger grids.\newline{}
   
   Some overhead is inevitable in any code, but the amount of effort put into simplifying a problem (such as creating arrays of neighbours)
   should depend on the expected size of the problem. Our code could probably have had less overhead, allowing it to run faster with smaller gridsizes,
   but this would likely led to it having a worse (linear) scaling with cell number.
   
   
   
   \section{Analysis} %tom+chen
   
   \begin{figure}[h]
   
   \input{figs/overhead.tex}
   \caption{\label{overhead}This is a graph of total time spent on each cell, which shows that overheads such as array initialization
   and output (i.e. things not directly involved in the simulation) take up a significant fraction of computation
   time with grids smaller than $\sim$100 by 100.}
   \end{figure}

  




\chapter{Conclusions} %everyone

   \begin{figure}[h]
   
   \input{figs/density.tex}
   \caption{Population density vs. time for Hares and Pumas. This periodic behaviour is typical of predator-prey interactions.}
   \end{figure}

\chapter{Group Evaluation} %everyone

\end{document}
