\documentclass[12pt]{report}
\title{Computational Physics Project: a Simulation of a Quantum Computer}
\author{Daniel Homer, Stephen Lloyd, James McKellar, Dmitry Tsigelnitskiy}
\date{March 2011}

\usepackage{tikz}
\usepackage{verbatim} 
\usepackage{pict2e}
\usepackage[pdftex]{hyperref}
\input{Qcircuit}


\begin{document}

\usetikzlibrary{shapes,arrows}


\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']

\maketitle

\begin{abstract}
In this project a quantum computer was simulated  in Java\cite{0}, to utilize Grover's Algorithm\cite{1}. The simulator was created using a matrix approach. As the efficiency of the quantum computer is a consequence of the fundamental properties of its operations, theoretical efficiency of a quantum computer cannot be achieved using a classical computer. For Grover's algorithm simulated on a classical computer, the classical search would have to be performed. So, in fact, to get the simulator to be as efficient as possible, a classical algorithm would have to be used. As a result, we concentrated on the theory and the use of object oriented design to visualize it. Grover's algorithm was simulated and then was tested for a number of steps the quantum computer would use to get the result.\footnote{When writing this report, a lot of emphasis was put on interactivity, so, a reader would benefit from reading an electronic version (PDF) rather than a paper one}
\end{abstract}

\tableofcontents

\chapter{Introduction and Theory}

\section{Classical Computer}
\footnote{The theory explained was done with help from a ''Basic concepts in quantum computation'' paper\cite{2} and a book ''Quantum Computing Explained''\cite{3}
}
Classical computers, like the ones we were working on, are completely deterministic due to their dependance on a binary system. This property of the computer is so fundamental because it is a result of the very physical components that they are composed of.
The classical computer is physically based on transistors which amplify, change or stop the flow of electrons. These transistors are used to construct logic gates: small collections of transistors which give certain outputs for certain inputs.
For example, a classical $AND$ gate has two inputs and one output. It will only produce an output of value 1 if both inputs are also of value 1. Input of a 1 and a 0 will result in output of 0.
A transistor-based classical computer releases tiny bursts of current in varying patterns, which is essentially what makes up what we would think of as “data”.  This system means that at any given time, a bit of information in the system can either be in a state of 1 or 0 (ie, on or off, depending on whether the current logic gate is outputting current or not). The implication of this is that the computer which is made of such components will be deterministic. There will never be an element of chance involved; the process of calculation, and by extension output is either a definite''yes'' or ''no''. These logic gates are arranged in a network that allows them to be used to solve algorithms. When varying patters of bits are fed into the network, the ''answer'' will emerge on the other side of the logic gates.

\section{Brief History of Quantum Computing}

A quantum computer is fundamentally different to this.
The idea of using quantum behaviour for computation was first proposed in the 1970s. It was proposed by several theoretical physicists such as Richard Feynmann, Paul Benioff and David Deutsch\cite{4}.
However to begin with, the practicality of this was heavily disputed. 
While most conceded that theoretically a quantum computer would work, the impracticality of harnessing sub atomic systems seemed to greatly outweigh any proposed advantage that could come of it. \\ \\
In 1994, Peter Shor produced an algorithm for a quantum computer that factorised large numbers tremendously quicker than a classical computer could\cite{5}. This was the first indisputable piece of evidence that quantum computers were potentially advantageous to classical computers. Following this discovery, there was a tremendous increase in research into quantum computing by physicists and computer scientists. Suddenly there was a reason for further research.
While many algorithms solved using quantum computation give a definite yes or no answer(for example, see Section \ref{sec:deutsch}), the quantum computer itself is not built using the same deterministic transistor-based technology that one would find in a classical computer. Quantum computers make use of several properties specific to quantum mechanics, such as entanglement and superposition.
This fundamental difference between classical and quantum computers means that a quantum computer can solve certain algorithms exponentially faster than a classical one.
\section{Tensor product}
When working with quantum bits and quantum gates, it is very important to understand tensor products. Tensor products are extremely mathematically intensive to calculate from a computational point of view. Not because there is any particularly complicated or abstract mathematics involved, but rather there are huge numbers of small calculations to make. To make matters more difficult, as the size of the register or gate increases, the number of calculations increases exponentially. \\
If we want to take the tensor product of two matrices A and B
\begin{equation}
A =  
\left[
{
\begin{array} {cc}
a_{11} & a_{12} \\
a_{21} & a_{22} \\
\end{array}
}
\right]
\\
B =  
\left[
{
\begin{array} {cc}
b_{11} & b_{12} \\
b_{21} & b_{22} \\
\end{array}
}
\right]
\end{equation}
then we do this by replacing every element in matrix A with the scalar multiple of that element and the whole of matrix B:
\begin{equation}
A \otimes B =  
\left[
{
\begin{array} {cccc}
a_{11}b_{11} & a_{11}b_{12} & a_{12}b_{11} & a_{12}b_{12} \\
a_{11}b_{21} & a_{11}b_{22} & a_{12}b_{21} & a_{12}b_{22}\\
a_{21}b_{11} & a_{21}b_{12} & a_{22}b_{11} & a_{22}b_{12} \\
a_{21}b_{21} & a_{21}b_{22} & a_{22}b_{21} & a_{22}b_{22} \\
\end{array}
}
\right].
\end{equation}
Registers would classically contain N bits and would be of size N. However in a quantum computer, a register of qubits is calculated by tensoring those qubits together. Similarly, when a gate is needed of a certain dimension, it is tensored with itself until it is of the same dimension as the register that it is working on.
This was only used in the first version of the code. In later versions the methods using tensor products were removed from most areas due to their tremendous computational cost.
\section{Qubits and Quantum registers}
\subsection{Qubits}
The qubit is the quantum equivalent of a bit. While like a bit, it has two potential states that it can be in (1/0, on/off), however while a bit is definitely one or the other, a qubit can be 0, 1, or some superposition of the two. This definition leads us to represent a qubit as a linear combination of the two states with each state multiplied by its respective probability:
\begin{equation}
|\psi\rangle = \alpha |0 \rangle + \beta |1\rangle
\end{equation}
Here, $\alpha$ and $\beta$ are the respective probability amplitudes of the two potential states. They are both complex numbers, that is, they have both real and imaginary components.
Physically, qubits are harder to define than their classical cousins. A classical bit is easily defined as either a small current, or a lack thereof. But since qubits are subject to various quantum properties like entanglement and superposition, they cannot be defined so simply. \\ \\
 A very good way to visualize a qubit in a superposition of states would be a ''Bloch Sphere'' (Figure \ref{bloch})\footnote{This figure was drawn using latex picture environment; the ellipse was drawn using bezier curves as described by Dr. Urs Oswald \cite{6}}. Vector $|\psi\rangle$ represents a possible state of the qubit, if the vector is in the top hemisphere, it is more likely to collapse to state $|0 \rangle$, if it is in the bottom hemisphere, it is more likely to collapse to state $|1 \rangle$ during a measurement.
\setlength{\unitlength}{1mm}
\begin{figure}[htb]
\begin{center}
\begin{picture}(60, 60)
\put (30, 30) {\circle{50}}
\put (30, 30) {\vector(1,0) {30}}
\put (30, 30) {\vector(0,1) {30}}
\put (30, 30) {\vector(-3, -3) {15}}
\put (30, 30) {\line(2,3) {10}}
\linethickness{0.035mm}
\qbezier(54.9624, 31.3701)(54.8489, 33.4381)(47.4573, 34.499)
\qbezier(47.4573, 34.499)(40.0658, 35.56)(29.726, 34.9925)
\qbezier(29.726, 34.9925)(19.3862, 34.425)(12.1551, 32.5614)
\qbezier(12.1551, 32.5614)(4.9241, 30.6979)(5.0376, 28.6299)
\qbezier(5.0376, 28.6299)(5.1511, 26.5619)(12.5427, 25.501)
\qbezier(12.5427, 25.501)(19.9342, 24.44)(30.274, 25.0075)
\qbezier(30.274, 25.0075)(40.6138, 25.575)(47.8449, 27.4386)
\qbezier(47.8449, 27.4386)(55.0759, 29.3021)(54.9624, 31.3701)
\put (30, 5) {\circle*{3}}
\put (23, 1) {$|1\rangle$}
\put (23, 57) {$|0 \rangle$}
\put (42, 42) {$|\psi\rangle$}
\put (34, 57) {$z$}
\put (15, 13) {$x$}
\put (57, 33) {$y$}
\put (40, 45) {\circle*{1}}
\put (30, 55) {\circle*{3}}
\end{picture}
\end{center}
\caption{Bloch Sphere : vector $\psi$ denotes a possible state of a qubit}
\label{bloch}
\end{figure}
 One potential qubit would be a single electron. The two states are represented by the electron having either an up or down spin.
The probability of finding the qubit in one of the states is equal to the square of the probability amplitude of that state. Since there is an absolute certainty that the qubit is in one of the two states, the sum of the squares of the two probability amplitudes is:
\begin{equation}
\label{eq:qubit}
|\alpha|^2 + |\beta|^2 = 1
\end{equation}
This condition becomes key to calculation later on. When this condition is true, we say that the qubit is ''normalised''.
Quantum states behave in a way that is mathematically similar to physical vectors. For this reason, when discussing quantum computation, we say that all calculations take place in what we call a ''vector space''. Qubits can be represented in vector notation as
\begin{equation}
\ket{\psi} = 
\left[
\begin{array}{c}
\alpha \\
\beta \\
\end{array}
\right],
\end{equation}
then qubits in states $\ket{0}$ and $\ket{1}$ would look like 
\begin{equation}
\ket{0} = 
\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
\ket{1} = 
\left[
\begin{array}{c}
0 \\
1 \\
\end{array}
\right].
\end{equation}
A superposition of all the states will be represented as
\begin{equation}
\frac{1}{\sqrt{2}}
\left[
\begin{array}{c}
1 \\
1 \\
\end{array}
\right].
\end{equation}
Note that the probabilities $\alpha^2$ and $\beta^2$ have to add up to 1, and should be equal for superposition of all the states
\subsection{Quantum registers}
To represent binary numbers in a quantum computer, a quantum register has to be created. So, to represent binary number 2 in a quantum computer, two qubits have to be tensored together:
\begin{equation}
\ket{1} \otimes \ket{0} = \ket{10}
\end{equation}
A similarity can be seen between quantum and classical representation. To represent 2 as a vector, $\ket{1}$ and $\ket{0}$ vectors are tensored together:
\begin{equation}
\left[
\begin{array}{c}
0 \\
1 \\
\end{array}
\right]
\otimes
\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= \left[ \begin{array}{c}
0 \\
0 \\
1 \\
0 \\
\end{array} \right]
\end{equation}
The main advantage of a quantum computer is that a whole register can be a superposition of all its states:
\begin{equation}
\frac{1}{2} \left[ \begin{array}{c}
1 \\
1 \\
1 \\
1 \\
\end{array} \right]
\end{equation}
In general, a register cannot be represented by a tensor product, such register would be called ''entangled''. an example of such register would be
\begin{equation}
\frac{1}{\sqrt2} \left[ \begin{array}{c}
1 \\
0 \\
0 \\
1 \\
\end{array} \right].
\end{equation}

\section{Quantum Gates}
A quantum logic gate is some form of device that performs a specific mathematical operation on a qubit. To make the calculation of the output of a system simpler, we represent quantum logic gates as matrices. Recalling that the qubit is represented in vector form, this makes calculations fairly straightforward from a mathematical perspective: a gate acting on a register can be represented as simple matrix multiplication.
In this section gates used in the project are described. 
\subsection{Hadamard Gate}
The Hadamard gate is responsible for creating a superposition of all possible states out of a register in a certain state. Hadamard can also create a certain state out of superposition of states. As superposition principle is widely used in a quantum computer, one can imagine that every algorithm uses this gate extensively. The Hadamard gate is defined to be:

\begin{equation}
H = \frac{1}{\sqrt{2}} 
\left[
{
\begin{array} {cc}
1 & 1 \\
1 & -1 \\
\end{array}
}
\right]
\end{equation}
In the later sections, quantum networks are used to show schematically the interactions between the gates and qubits. In a quantum circuit, Hadamard Gate would be: \\
\hspace*{55mm}\Qcircuit @C=2em @R=1.4em{
& \gate{H} & \qw
}
\subsection{More than one qubit}
Most of the times, one is working on a register that consists of more than one qubit. Naturally, the whole register would be passed through the gate. Turns out, representing that mathematically is trivial: a gate is tensored with itself to be of the right dimension. An example of a Hadamard gate for two qubit register:
\begin{equation}
H \otimes H = \frac{1}{\sqrt{2}} 
\left[
{
\begin{array} {cc}
1 & 1 \\
1 & -1 \\
\end{array} 
}
\right] \otimes \frac{1}{\sqrt{2}} 
\left[
{
\begin{array} {cc}
1 & 1 \\
1 & -1 \\
\end{array} 
}
\right] = \\ = \frac{1}{2}
\left[
{
\begin{array} {cccc}
1 & 1 & 1 & 1\\
1 & -1 & 1 & -1 \\
1 & 1 & -1 & -1  \\
1 & -1 & -1 & 1 \\
\end{array} 
}
\right]
\end{equation}
\subsection{Phase Gate}

The phase gate is defined to be:
\begin{equation}
R_{\theta} = 
\left[
{
\begin{array} {cc}
1 & 0 \\
0 & e^{i\theta} \\
\end{array}
}
\right]
\end{equation}
This gate gives a phase shift of $\theta$ to state $|1\rangle$. This gate is the key element of Grover's algorithm: Section \ref{GrAlg}. \\
Once the qubit has ''passed through'' a quantum gate it is in some way mathematically changed. In a quantum circuit the gate would be: \\
\hspace*{50mm}\Qcircuit @C=2em @R=1.4em{
& & \theta\\
& \qw & \gate{R_{\theta}} \qw & \qw &\qw
}
\\ \\ where $\theta$ represents the angle of phase shift.
A basic phase gate can be extended to shift any qubit in a register, these are refered to as ''controlled phase gates'':
\begin{equation}
R_{\theta} = 
\left[
{
\begin{array} {ccccccc}
1 & 0 & \hdots  & 0 & \hdots & 0\\
0 & 1 & \hdots  & 0 & \hdots & 0\\
\vdots & \vdots & \ddots  & \vdots & \hdots & 0\\
0 & 0 & \hdots & e^{i\theta}  & \hdots & 0\\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots\\
0 & 0 & \hdots & 0 & \hdots & 1 
\end{array}
}
\right]
\end{equation}
This gate shifts an arbitrary chosen qubit by a phase of $\theta$.
\section{Quantum Circuits}
A quantum circuit is a very useful tool to visualize a quantum algorithm or any kind of interaction between qubits and quantum gates. Suppose, there is a qubit of state $|0 \rangle$ and a Hadamard gate acting on it: Such a circuit would be shown as: \\ 
\hspace*{57mm} \Qcircuit @C=2em @R=1.4em{
\lstick{\ket{0}}& \gate{H} & \rstick{\ket{0}+\ket{1}}\qw
} \\ \\
Note that $\ket{0} + \ket{1}$ represent normalized superposition of states 1 and 0, i.e. in equation \ref{eq:qubit} $\alpha$ and $\beta$ are $\frac{1}{\sqrt{2}}$, also, $\ket{0} - \ket{1}$ mean that $\alpha$ is equal to $\frac{1}{\sqrt{2}}$ and $\beta$ is $-\frac{1}{\sqrt{2}}$ in equation \ref{eq:qubit}.
\\ \\
Sometimes, gates act on more than one qubit, the so-called two-qubit gates are very common. An example of such a gate would be a controlled-not gate. In quantum circuit such a gate will look like: \\ \\
\hspace*{45mm}\Qcircuit @C=4em @R=2.8em{
\lstick{\ket{x}}& \ctrl{1} &\qw &\rstick{\ket{x}} \\
\lstick{\ket{y}}& \targ  & \qw &\rstick{\ket{x \oplus y}}
} \\ \\ \\
Here, the qubit $\ket{x}$, ''control qubit'' is unchanged, but determines the nature of the algorithm (here does nothing if x=0 and inverts the second qubit if x=1). The symbol $\oplus$ stands for addition modulo 2. The full study of controlled-not gate is beyond the scope of this report, but the concept of two-qubit gate is useful in the following sections. Note that 3-qubit, 4-qubit, etc. gates are also possible but not that common.

\chapter{Algorithms}
An algorithm can be thought of as a network of gates(classical or quantum) connected together to perform certain tasks. Naturally, a working model of a computer should be able to perform some algorithms.
\section{Deutsch-Jozsa Algorithm}
\label{sec:deutsch}
This is the first algorithm that was consiered, as it shows very clearly in what way a quantum computer can be superior to classical ones. The situation is as follows: There is a ''black box'' That can take 1 or 0 as input and produce 1 or 0 as output. A box is thought of as a function $f(x)$ where x can be 0 or 1. It is clear, that a box can be in 1 of the 4 states:
\begin{itemize}
\item $f(0)=0$, $f(1)=0$
\item $f(0)=0$, $f(1)=1$
\item $f(0)=1$, $f(1)=0$
\item $f(0)=1$, $f(1)=1$
\end{itemize}
The 1st and the last state are refered to as being ''constant'', the others are refered to as ''balanced''. The task is to determine whether the ''black box'' is constant or balanced. Classically, one needs two queries to black box: to know the result for input one and zero. However, with a quantum computer it is possible to find the answer with only one query. Algorithm proposed by Deutsch did solve the question, however, the answer was not deterministic, in fact, the answer was 50\% certain\cite{7}. Nevertheless, the algorithm described in this section is deterministic, it is an improved version of the original Deutsch algorithm\cite{8}. This algorithm can be represented as a quantum circuit: \\ \\
\hspace*{17mm}\Qcircuit @C=4em @R=2.8em{
\lstick{\ket{0}}& \gate{H} &\ctrl{1}  &\gate{H} &\qw &\rstick{result} \\
\lstick{\ket{0}-\ket{1}}& \qw 	&\gate{f}  & \qw & \qw &\rstick{\ket{0}-\ket{1}}
} \\ \\ \\
Note that if function $f$ takes $(x,y)$, then the result can be represented as $(x,y \oplus f(x))$. This algorithm's input is $\ket{0}(\ket{0}-\ket{1})$, after the first Hadamard gate becomes $(\ket{0}+\ket{1})(\ket{0}-\ket{1})$. Now, for $x \in$ \{ 0,1 \} under the effect of the ''black box'' \cite{9}
\begin{equation}
\ket{x}(\ket{0}-\ket{1}) \longrightarrow \ket{x}(\ket{0 \oplus f(x)}-\ket{1 \oplus f(x)})
\end{equation}
leading to:
\begin{equation}
(-1)^{f(x)}\ket{x}(\ket{0}-\ket{1})
\end{equation}
expanding the left part gives:
\begin{equation}
((-1)^{f(0)}\ket{0}+(-1)^{f(1)}\ket{1})(\ket{0}-\ket{1})
\end{equation}
using the states of the ''black box'' described earlier, becomes
\begin{itemize}
\item $(\ket{0}+\ket{1})(\ket{0}-\ket{1})$
\item $(\ket{0}-\ket{1})(\ket{0}-\ket{1})$
\item $(-\ket{0}+\ket{1})(\ket{0}-\ket{1})$
\item $(-\ket{0}-\ket{1})(\ket{0}-\ket{1})$
\end{itemize}
respectively. acting with a Hadamard Gate on the first qubit gives
\begin{itemize}
\item $\ket{0}$
\item $\ket{1}$
\item $-\ket{1}$
\item $-\ket{0}$
\end{itemize}
respectively. $\ket{0}$ is the same as $-\ket{0}$ when measuring, so the algorithm returns $\ket{0}$ for constant function and $\ket{1}$ for balanced function. The algorithm gives a deterministic result by accessing black box only once. Although this algorithm is not particulary useful in practice, it was implemented in the first version of the simulator as it helps understanding quantum computing better and Grover's algorithm in particular.
\section{Grover's Algorithm}
Grover's Algorithm was first put forward by Lov Grover \cite{10} in 1996. It is a method whereby using a quantum computer, the search of an unordered list or database can be done for a fraction of the computational cost of that of a classical computer.
\subsection{Classical search}
When faced with an unordered list of size N a classical computer must approach a search of this list in only one way. If for example we are looking for the letter ''x'' in a scrambled list of the alphabet, a Classical computer has no other option than to search each entry in the list systematically and check with a Boolean statement whether it is the letter ''x''. It may occur that it finds it in the first entry of the list; however it will be equally likely to find it in the last entry. This means that the classical computer cannot recover the search in any less than the order of $N$ steps\cite{11}.
\subsection{Quantum search}
\label{GrAlg}
 In quantum computing the process can be greatly enhanced. Due to the nature of a quantum register of qubits, all possible states can be represented simultaneously; a search can be undertaken on all states at once. If we again take the example of a scrambled alphabet, classically we would map this on to a register of bits and we could represent the first entry in the list as ''000\ldots00'', the second entry as ''100\ldots00'' etc. In order to search this list each bit must be switched to ''1'' or ''0'' to represent the binary representation of each entry. \\ \\ Quantum computing registers represent each entry as a probability and to begin with there is equal probability of finding every entry. The Grover's Algorithm uses Phase and Hadamard gates to increase the probability of finding the correct answer. Because it can do this by applying changes to all qubits in the register simultaneously the answer is found in far fewer steps. Each step has the effect of reducing the probability of all the entries that do not correspond to the correct answer and increasing the probability of the correct one.\\ \\ As stated the algorithm employs only two types of quantum gate, firstly the Phase gate and Secondly the Hadamard gate. The Phase gate firstly acts on the superposition register $\ket{\psi}$ to invert the phase of the entry which contains the correct answer by a phase of $\pi$. This has the effect of inverting the sign. The Hadamard is then applied followed by another Phase gate which phase shifts the zero state of the register. The final step is to pass the register through the Hadamard gate to produce a result. This final stage amplifies the probability of the correct answer.The effect this algorithm has is a rotation of the register into a more favourable position:
\\
\hspace*{30mm}\Qcircuit @C=2em @R=0.7em{
& \pi & & \pi & \\
\lstick{\ket{\psi}}& \gate{R_{x}} \qw &\gate{H} &\gate{R_0} \qw &\gate{H}  &\qw &\rstick{result}}
\\ \\  \\
Our simulator shows a quantum qubit as vector, represented by a matrix in Java. A quantum register is a tensor product of these matrices. At the start of the algorithm a zero register is created; this can be done in one of two ways. Either a zero qubit [1,0] is created and tensored  together with itself the desired number of times, or an empty matrix the appropriate length is created and filled with
\begin{equation}
\left[
\begin{array} {ccccc}
1 & 0 & 0 & \hdots & 0
\end{array}
\right]
. 
\end{equation} 
The second method is by far the quickest and most convenient way to create a quantum register in the zero state but obviously does not show the quantum theory of creating a register. Similarly to create a fully entangled register the zero register can either be passed through a Hadamard gate or an empty matrix filled with \\
\begin{equation}
\left[
\begin{array} {ccccc}
1 & 1 & 1 & \hdots & 1
\end{array}
\right]
\end{equation}
and sufficiently normalised. The method that creates these from the basic elements was prefered as it shows how to create any size register and appropriate gate from the base elements, taking as an argument the number of qubits to be used. The problematic section of the Grover's Algorithm is creating the phase gate. In quantum computing the gate would act on the whole register at once and invert the phase of the desired result. In a classical simulator in order to do this we must first carry out the equivalent of a classical search to know which element of our register vector we want to invert. The Phase gate is created by first creating an Identity matrix and setting the diagonal element which will be responsible for the phase shift to ''-1''. When the register is acted upon by the phase gate the Identity matrix returns the same result as the input. Having one element set to ''-1'' instead of ''1'' changes the sign of that element in the register. This is a simplistic approach to the Phase gate which is usually represented as having diagonal elements $e^{i\phi}$ but when $\phi=0$ the element reduces to ''1'' and when $\phi=\pi$ the element reduces to ''-1'' when dealing with real numbers.  In this way the problem has been somewhat simplified by the simulator but this is to be expected. The simulator uses only three gates, The Hadamard, the Phase-x and the Phase-0. These act in succession on the register as seen below: \\ \\ 
\begin{tikzpicture}[node distance = 5cm, auto]
\node [block] (1) {Input};
\node [block, right of=1] (2) {Phase-X};
\node [block, right of=2] (3) {Hadamard};
\node [block, below of=3] (4) {Phase-0};
\node [block, left of=4] (5) {Hadamard};
\node [block, left of=5] (6) {Output};

\path [line] (1) -- (2);
\path [line] (2) -- (3);
\path [line] (3) -- (4);
\path [line] (4) -- (5);
\path [line] (5) -- (6);
\path [line] (6) -- (1);
\end{tikzpicture}
\\ \\
After each cycle the magnitudes of each element in the array which represent the probability of each entry in our unordered list have been altered. The magnitudes of all entries that do not correspond to the correct answer have been lessened and the entry that corresponds to the correct answer has been amplified. By repeating this cycle we end up with one entry in the register corresponding to the desired entry in the list having nearly 100\% probability while all others fall off to practically zero. 
\begin{figure}[h!]
\includegraphics[scale = 0.4]{IM.png}
\includegraphics[scale = 0.4]{FM.png}
\caption{Initial Magnitude and Final Magnitude}
\label{fig:IM}
\end{figure}
Figure \ref{fig:IM} shows the start and end results of the algorithm. By mapping each entry in our unordered list to each element in the register then we have found the correct entry we are looking for using only the order of $\sqrt{N}$ calculations. Obviously within our simulation this is not entirely accurate as each time we start the algorithm we must perform a classical search on the list in order to initialise the Phase-x gate but if we consider each cycle of the algorithm as one operation of a quantum computer then we see that the number of operations compared to that of a classical search is greatly reduced.
\chapter{Code Design}
\section{CRC Analysis}
\label{sec:CRC}
By writing our quantum simulator in java, it allowed us to take advantage of good object orientated practise to create something that is modular and logical in structure.  This meant that we were able to come back to the project and improve it without changing large amounts of code at a time; resulting in a number of revised versions of the simulator, each being an improvement on the last.

\section{Version 1}


\begin{tikzpicture}[node distance = 2.5cm, auto]
\node [block] (Complex) {Complex};
\node [block, right of=Complex] (Vector) {Vector};
\node [block, right of=Vector] (Gate) {Gate};
\node [block, right of=Gate] (Grovers) {Grovers};
\end{tikzpicture}
\\ \\
Initial versions of the simulator were focussed on first achieving results for our Grover's algorithm.       This was a valuable learning exercise in not only understanding the significance of the algorithm itself, but also on how its implementation should shape the rest of the simulator.  This algorithm-centred design focus motivated several changes to our initial class structure; such as abstracting different gates in to their own respective classes, each extending a base class called Gate.  This gave the code a logical class structure that made algorithm implementation easier for both the coder and the reader.  An algorithm-centred design structure also naturally motivated computational optimisation. 

\section{Version 2}


\begin{tikzpicture}[node distance = 2.7cm, auto]
\node [block] (Complex) {Complex};
\node [block, right of=Complex] (Vector) {Vector};
\node [block, right of=Vector] (Matrix) {Matrix};
\node [block, right of=Matrix] (Gate) {Gate};
\node [block, below of=Gate] (Hadamard) {Hadamard};
\node [block, right of=Hadamard] (Phase) {Phase};
\node [block, below of=Complex] (Algorithm) {Algorithm};
\node [block, right of=Algorithm] (Grovers) {Grovers};

\path [line] (Gate) -- (Hadamard);
\path [line] (Gate) -- (Phase);
\path [line] (Algorithm) -- (Grovers);
\end{tikzpicture}
\\ \\ 
Taking advantage of class abstraction resulted in other similar changes in subsequent simulator revisions. Noticing that both registers and gates required the same methods such as tensor products and matrix multiplications. We were able to write a base super class called Matrix which was extended by both Register and Gate. This superclass contained single methods that could be used by both.  This abstraction resulted in less overall code, that was somewhat more analogous to the mathematical formulation of gates and registers as matrices. 
\section{Version 3}


\begin{tikzpicture}[node distance = 2.7cm, auto]

\node [block]  (Complex) {Complex\\ \ref{sec:Complex}};

\node [block, right of=Complex] (Matrix) {Matrix \\ \ref{sec:Matrix}};

\node [block, right of=Matrix] (Gate) {Gate\\ \ref{sec:Gate}};

\node [block, below of=Gate] (Register) {Register\\ \ref{sec:Register}};

\node [block, right of=Gate] (Hadamard) {Hadamard\\ \ref{sec:Hadamard}};

\node [block, below of=Hadamard] (Phase) {Phase\\ \ref{sec:Phase}};

\node [block, right of=Hadamard] (Grover) {Grover \\ \ref{sec:Grover}};


\path [line] (Matrix) -- (Gate);

\path [line] (Matrix) -- (Register);

\path [line] (Gate) -- (Hadamard);

\path [line] (Gate) -- (Phase);

\end{tikzpicture}


\begin{comment}
\begin{itemize}
\item Class(Superclasses, Subclasses)
\item Complex (Superclass: N/A, Subclasses: N/A)
\item Matrix (Superclass: N/A, Subclasses: Gate, Register)
\item Matrix (Superclass: N/A, Subclasses: Gate, Register)
\item Gate (Superclass: Matrix, Subclasses: Phase, Hadamard)
\item Hadamard (Superclass: Gate, Subclasses: N/A)
\item Phase (Superclass: Gate, Subclasses: N/A)
\item Grover (Superclass: N/A, Subclass: N/A)
\item Shor (Superclass: N/A, Subclass: N/A)
\end{itemize}
\end{comment}

\subsection{Class: Complex}
\label{sec:Complex}
\begin{itemize}
	\item [Responsibilities:]
	\begin{itemize}
		\item Defines a complex object in terms of real and imaginary class variables. 
		\item Contains methods for complex addition, multiplication and 2-norm (magnitude) finding.
	\end{itemize}
	\item [Collaborations:]
	\begin{itemize}
		\item Used throughout the simulator, as all possible numerical values are assumed complex.  The tradeoff here between the additional memory cost of storing real values as Complex objects (imaginary part being zero still having to be allocated as 0 in memory) and the ease of code reading and writing by doing so is discussed later in the report.
		\item Matrix
		\item Register
		\item Hadamard
		\item Phase
	\end{itemize}
\end{itemize}
\subsection{Class: Matrix}
\label{sec:Matrix}
\begin{itemize}
	\item [Responsibilities:]
	\begin{itemize}
		\item Defines a mathematically general $m*n$ matrix.
		\item Contains general methods for matrix multiplication and tensor products as well as methods for normalisation and output formatting.
	\end{itemize}
	\item [Collaborations:]
		\begin{itemize}
		\item Used as the chosen formulation of how gates should act on registers and also how gates and registers are built up in the multi-qubit case.
		\item All subclasses of Matrix and subsequent sub-subclasses
	\end{itemize}
\end{itemize}
\subsection{Class: Gate}
\label{sec:Gate}
\begin{itemize}
	\item [Responsibilities:]
	\begin{itemize}
		\item Defines a gate as a matrix
		\item Contains no methods other than the constructor which defines it to be a type of matrix. Used logically to define all gates, such as Phase and Hadamard as matrices so that they all inherit the same matrix methods required.
	\end{itemize}
	\item [Collaborations:]
		\begin{itemize}
		\item Only responsible for its subclasses
		\item Only responsible for its subclassesHadamard
		\item Phase 
	\end{itemize}
\end{itemize}
\subsection{Class: Register}
\label{sec:Register}
\begin{itemize}
	\item [Responsibilities:]
	\begin{itemize}
		\item Defines a n-qubit register object
		\item Contains methods for checking if two registers are equal and how to normalise them.
	\end{itemize}
	\item [Collaborations:]
		\begin{itemize}
		\item Used by algorithm classes as the fundamental objects being acted upon
		\item Grover
	\end{itemize}
\end{itemize}
\subsection{Class: Hadamard}
\label{sec:Hadamard}
\begin{itemize}
	\item [Responsibilities:]
	\begin{itemize}
		\item Defines a n-qubit Hadamard gate object
		\item Contains constructor to create a n-qubit gate using only its functional representation rather than tensoring a single Hadamard gate n times.  This will improve computational cost dramatically and will be discussed later.
	\end{itemize}
	\item [Collaborations:]
		\begin{itemize}
		\item Used in algorithms in forming a network of gates acting on registers
		\item Grover
	\end{itemize}
\end{itemize}
\subsection{Class: Phase}
\label{sec:Phase}
\begin{itemize}
	\item [Responsibilities:]
	\begin{itemize}
		\item Defines n-qubit Phase gate object in terms of a double class variable which determines the magnitude of the phase shift.
		\item Contains constructor to create a n-qubit gate again using only functional representation with the same benefits as for Hadamard
	\end{itemize}
	\item [Collaborations:]
		\begin{itemize}
		\item Again used by algorithms in forming a network of gates acting on registers
		\item Grover
	\end{itemize}
\end{itemize}
\subsection{Class: Grover}
\label{sec:Grover}
\begin{itemize}
	\item [Responsibilities:]
	\begin{itemize}
		\item Contains a method for running the Grover's quantum search algorithm as described in the previous section
	\end{itemize}
\end{itemize}
\section{Code Optimisation and Efficiency}
One obvious and important motivation behind our simulator design was efficiency.  As well as writing code that took advantage of good object orientated practice, it is important to achieve results  as efficiently as possible.  With subsequent simulator revisions; several code optimisations were put in place as well as design changes which increased efficiency.
\\ \\
One particular example of a good code optimisation was the realisation that our code was explicitly calculating powers of 2. Our code regularly called upon the Math.pow() method to calculate $2^n$, for example, when determining the dimensionality of registers and gates. This method uses logarithms to calculate powers of any base \cite{12}. Integers are already stored as binary numbers in memory. It seemed more natural, and efficient, to simply use a bit-shift operation.  By using the signed left bit-shift method, <<, the binary representation of the number 2 (10 in binary) is shifted to the left by a certain amount.  This has the effect of appending a 0 to the right hand side of the bit pattern.
\begin{equation}
10 \rightarrow << \rightarrow 100 \rightarrow << \rightarrow 1000
\end{equation}
Hence powers of 2 could be calculated by writing:
\begin{equation}
2 << (n-1) \rightarrow 2^n
\end{equation}
An example of an overall design change was motivated by the large computational cost of calculating tensor products.  Initial revisions of the simulator involved tensoring gates and registers with themselves N times, where N is the number of qubits used in the calculation.  For large N, this required a lot of floating point operations.  Tensor products are key in understanding how our objects interact, but we avoided using them as much as possible in later simulator revisions.  Writing down N-qubit registers and N-qubit phase gates without using tensor products was trivial, but more complicated when considering an N-qubit Hadamard gate.  To avoid tensoring a single qubit Hadmard gate together N times, we decided to seek a functional formulation of the Hadamard transform to construct the matrix.  It was found that the rows of a N-qubit Hadmard gate are defined by the Walsh functions\cite{13}.  This gives us a method for generating elements of the matrix:
\begin{equation}
(H_n)_{i,j} = \frac{1}{2^{\frac{n}{2}}}(-1)^{i\cdot j}
\end{equation}
where $i\cdot j$ is the bitwise dot product of the binary representations of i and j. for example, for i=4, j=5:
\begin{equation}
4\cdot 5 = 100 \cdot 101 = (1\times 1)+(0\times 0) +(0 \times 1) = 1
\end{equation}
Although in practice this required a lot of casting, calculating and then recasting in java; it was found to be a lot more efficient than calculating tensor products for large values of N. \\ \\ If given more time on this task, further optimisation measures could be taken.  One example of this would be to avoid matrix representation as much as possible or to at least use a sparse representation when storing them in memory.  For large numbers of qubits, roughly 12 or more, it was found that the memory allocation of the large resultant gates was exceeding the Java heap size.  Rather than simply increasing the heap space allocated to the JVM, measures could be taken to avoid the problem of large memory cost all together.  Sparse representation would avoid storing repeated elements of the same value in a matrix which would help reduce memory cost.  A better way would have been to use functional representation rather than a matrix one.  For example, a Hadamard matrix can be treated as a functional Hadamard transform. This way it does not require the creation of additional objects to be stored in memory.  A matrix representation seemed like a natural approach and this made it easier to see how everything is built up using basic objects.
\chapter{Results and Analysis}
\section{Results}

The results from 4 Qubits shown in Figure \ref{fig:4Q} show that it took the simulator 8 cycles to return a result
with a probability of greater the 99\%. This is as many steps as for 7 Qubits(Figure \ref{fig:7Q}). This can be attributed to
the tolerance of the program. If the simulator is told to stop once the probability reaches 98\% the
simulator would have terminated after 4 cycles. This would give the expected result of $\sqrt{N}$ cycles
for 16 entries in the list which is 4 cycles. \\ \\
\begin{figure} [H]
\includegraphics[scale = 0.4]{4Q.png}
\caption{4 Qubits Simulation}
\label{fig:4Q}
\end{figure}
\begin{figure} [H]
\includegraphics[scale = 0.4]{7Q.png}
\caption{7 Qubits Simulation}
\label{fig:7Q}
\end{figure}
In subsequent trials for 5 Qubits the simulator
terminated after 4 cycles(Figure \ref{fig:5Q}). For 32 entries available the answer should be found in the order of 5-6
steps and this is in a good agreement with the simulators actions. \\ \\ 
\begin{figure} [H]
\includegraphics[scale = 0.4]{5Q.png}
\caption{5 Qubits Simulation}
\label{fig:5Q}
\end{figure}
In all trials for 6 Qubits and above the simulator
returns the result in less steps than the expected value. Although the result was found quicker than
expected it was still within the order of magnitude expected. \\ \\ 
\begin{figure} [H]
\includegraphics[scale = 0.4]{6Q.png}
\caption{6 Qubits Simulation}
\label{fig:6Q}
\end{figure} 
For 8 Qubits (not graphed due to size
of data), the result is expected to be found in the order of 16 steps. The simulator found a 99\%
probability in only 11 steps but we can see this is very close to the expected number of steps. Taking
into account the results obtained from 4 Qubits it is unclear whether making the tolerance of the
simulator more sensitive would return results in the correct number of steps. In the case of 4 Qubits
when the result was not found after 4 steps due to the tolerance of the simulator, the magnitude of
the correct answer actually decreased before once again increasing to a magnitude of over 99\%.
Bearing this in mind if we make the simulator more sensitive and program the result to be returned
once the magnitude has reached 99.5\% or higher the cycle may never reach this and instead would
decrease again. 
\section{Analysis}
Analysis of the results in comparison to the expected results is plotted in figure \ref{fig:loop}.
\begin{figure} [t]
\includegraphics[scale = 0.7]{loop.png}
\caption{Analysis at 99 \% tolerance}
\label{fig:loop}
\end{figure} 
This shows the aberration arising for 3 and 4 qubits which requires the simulator to perform 100\% more cycles of the algorithm than is expected. This can avoided by lowering the tolerance of the algorithm to terminate once the magnitude of an entry is greater than 98\%. In practice this fixes the aberration, however it forces a larger deviation from the expected result in higher number of qubits. With a tolerance of 99\% all test simulations for higher numbers of qubits terminate before the expected $\sqrt{N}$ cycles. All are within an average 30\% deviation from the expected result. By increasing the sensitivity to 99.99\% the simulation still terminates before the expected result however, has a smaller deviation. In this case, for lower number of qubits the simulator is never able to reach the required magnitude or runs many more times than is expected. 

\section{Errors}
By exploring the theory behind quantum computation; we see that its calculations are inherently probabilistic.  This is reaffirmed by the results of the Grover's quantum search, where the process is not entirely deterministic.  We find that initially the algorithm converges to the correct answer in the unsorted list with increasing probability of success at each iteration.  However, we also found that if the program is not manually terminated at a given probability tolerance. The algorithm will then diverge away from the correct answer before converging again.  This process repeats and is best represented by looking at how the wave function defined by the unsorted list changes at each iteration.  \\ \\
This is best done by treating the wave function as a vector in a vector space spanned by a basis as defined by the qubits used in the computation.  This is analogous to the 1 qubit case of the Bloch sphere (Figure \ref{bloch}) where the wave function is free to rotate, this time in n-dimensional space, where n is the number of qubits.  The particular direction of the vector determines its state.  In this case, each element of the list would be defined by a particular point, defined by a phase, in the n-dimensional space. \\ \\ 
Each iteration of the algorithm involves changing the state of the wave function.  i.e. the wave function is rotated by a certain phase at each step which could be represented on a phase diagram.  The vector will converge to the correct answer with sufficient probability after $\sqrt{N}$ steps. It will then rotate out of phase with the correct answer unless the algorithm is terminated at this point. \\ \\ 
There is no definite correct answer when considering when to terminate the program.  Ideally, the program should terminate before the algorithm diverges away from the correct answer.  However, in a true quantum computer, there would be no way to observe the intermediate steps of the algorithm process. This is due to the inherent nature of the laws governing the quanta used to physically represent our qubits. That requires knowing the answer. The only way to determine when to terminate the program will be when the observer is satisfied with the probability of answer returned being correct. 
\\ \\ 
The choice of tolerance is completely dependant on the use of the quantum search.  If a more accurate answer is required; then a higher probability threshold can be used.  If the problem requires faster computation, for example if the list is very large, and the accuracy of the correct answer is not as important; then a lower probability threshold can be used.   There is clearly a tradeoff between computational cost and the resultant accuracy.  The error here is inherent to quantum mechanics and has nothing to do with the computer itself.  Any errors introduced by the possible physical limitations of qubit representation cannot be meaningfully explored in this report; with only access to classical computers.  The errors introduced by classical floating point computation in our simulation are negligible and can be ignored.
\chapter{Conclusions}
We can see from the results obtained that a quantum computer would be massively faster in finding a result when faced with an exponentially large number of entries, compared to a classical computer. Given a list of 256 entries a classical computer would take 256 computations to find the correct result. The expected results for a quantum computer would be the square root of the number of entries, 16. Our results from the simulator are in agreement with this taking into account an error term of 5 cycles. From this we can see that the comparison between classical and quantum grows with each qubit introduced. For each qubit introduced the number of possible entries in the list doubles. Classically the number of computations required will double but for the quantum case the number grows far less.
\begin{figure} [h!]
\includegraphics[scale = 0.7]{classicalquantum.png}
\caption{The expected results for up to 10 qubits or 1024 entries.}
\label{fig:CQ}
\end{figure}

\begin{figure} [h!]
\includegraphics[scale = 0.5]{classicalquantum2.png}
\caption{The comparison for up to 20 qubits or 1048576 entries.}
\label{fig:CQ2}
\end{figure}
These results show that the ratio of quantum to classical is $\sqrt{N}$. This means that for a register containing $n$ qubits the number of entries $N=2^n$. The classical computer will return the result in $2^n$ computations compared to the quantum computer which would only take $2^{\frac{n}{2}}$ computations. This will be of the order $2^{\frac{n}{2}}$ times less computations. \\ \\ 
Figure \ref{fig:CQ} clearly shows that the quantum search is nearly 30 times faster than the classical search for 10 qubits. Figure \ref{fig:CQ2} shows the massive difference between classical and quantum for 20 qubits. The quantum expectation is in the order of 1000 times faster than the classical expectation. 



\chapter{Group Evaluation}
For all of us, this was our first experience of programming as part of a group. While this in itself was potentially problematic, we were also left to organise the project by ourselves.  We were essentially thrown in at the deep end, and this forced us to take organisation very seriously.
Our first task was to fully understand the area of quantum computing. We had at this point previously studied quantum mechanics formally as part of our degrees, but we had no formal education in the area of quantum computing. For this reason we decided that before we attempted to code anything, we would spend about 3 weeks just reading up on the topic of quantum computing and the specific algorithms to ensure that we properly understood it. Once we had done this, it is fair to say that we each had a rough idea of how we were going to go about solving this problem.
Luckily, none of our ideas were particularly radically different, so from the start we more or less agreed on how we were going to go about making the program.
At this point, we organised a meeting where the four of us sat down and firmly decided which parts from whose ideas we were going to use and how it was all going to come together. We eventually settled on a system where entities such as complex numbers, matrices and gates were all handled by separate classes that are called upon as and when they are needed. \\ \\
Once this was decided on, we delegated classes out for each of us to write. This was probably the easiest part of the actual coding, since all we had done was to create various classes that described various components in a quantum network. The hardest part would be combing all the classes into an actual algorithm solving system. We expected this to take many weeks.
Much to everyone else’s surprise, after he had worked out how it worked on paper, Danny managed to make a working model of Grover's algorithm by himself in a matter of days.
Once this was done, and our program for all intents and purposes worked, Stephen thought it would be best if we tidied up the code. From the beginning we really just concentrated on getting the simulator working with little attention being paid to good programming practice. So we all got together and using a synched folder that contained all the files and classes we set about trying to partially rewrite the code to make it more organised and easier to read.
This proved very difficult, as we did not properly organise how to do it. All four of us were changing bits of code at once with very little communication about what we were doing. This led to the code ''breaking'', and we were presented with many compiling errors that we just could not seem to solve. The phrase ''too many cooks spoil the broth'' was practically written for our situation.
After we realised that this method was not working, it was decided that Stephen and Danny would focus on fixing the code, and James and Dmitri would begin the report. Sure enough, the code was eventually fixed and result taking could begin. \\ \\ 
Despite a few problems along the way, both technical and “political”, overall we managed to work quite well as a group. If we were to do a similar project again, though, there are a few things we would do differently. First of all, before writing a line of code we would all agree on set syntax, so that when we each went off and wrote separate sections of the program, there would be far fewer confusing compilation errors since we were all using the same terms. Another area we could have improved upon was communication; at times we needed to make it clear to each other who was doing what.
 Given that this was our first experience working as a group, and that we were left to organise everything ourselves, it’s fair to say that we were successful in tackling the project and dealing with any issues that arose along the way.

\begin{thebibliography}{99999}
\bibitem{0}
Java source code for the simulator \href{https://docs.google.com/leaf?id=0B-VyIbDI63PIOTdmZTk4NWItMDMzMC00NDBmLTg1OTQtNWI1NmJhZmI5ZTIy&hl=en}{https://docs.google.com/leaf?id=\\0B-VyIbDI63PIOTdmZTk4NWItMDMzMC00NDBmLTg1OTQtN\\WI1NmJhZmI5ZTIy\&hl=en}
\bibitem{1}
''From Schrödinger's equation to quantum search algorithm'', Grover L.K., Am. J. Phys., 69(7): 769-777 (2001)
\bibitem{2}
''Basic concepts in quantum computation'', Artur Ekert, Patrick Hayden, Hitoshi Inamori, Les Houches, Volume 72/2001, 661-701 (2001)
\bibitem{3}
''Quantum Computing Explained'', David McMahon  ISBN: 0470096993
\bibitem{4}
''Simulating physics with computers'', R.Feynman, International Journal of Theoretical Physics, Vol 21, Nos. 6/7, pages 467-488 (1982) 
\bibitem{5}
''Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer'', Shor Peter W., SIAM J. Comput. 26 (5): 1484–1509  (1997)
\bibitem{6}
A paper on graphics in \LaTeXe{} by Dr. Urs Oswald \href{http://www.ursoswald.ch/LaTeXGraphics/overview/latexgraphics.pdf}{http://www.ursoswald.ch/LaTeXGraphics/overview/latexgraphics.pdf} accessed on 08/03/2011
\bibitem{7}
"Rapid solutions of problems by quantum computation", David Deutsch and Richard Jozsa, Proceedings of the Royal Society of London A 439: 553. (1992)
\bibitem{8}
R. Cleve, A. Ekert, C. Macchiavello, and M. Mosca (1998). "Quantum algorithms revisited" (PDF). Proceedings of the Royal Society of London A 454: 339–354.

\bibitem{9}
''Quantum algorithms revisited'', R. Cleve, A. Ekert, C. Macchiavello, M. Mosca, Proc. R. Soc. Lond. A 454, 339-354 (1998)
\bibitem{10}
A page about Lov. K. Grover \href{http://www.bell-labs.com/user/lkgrover/}{http://www.bell-labs.com/user/lkgrover/} accessed 05/03/2011


\bibitem{11}
''The Art of Computer Programming'' Volume 3: Sorting and Searching, Donald Knuth, ISBN 0-201-89685-0.
\bibitem{12}
IBM Developers page
\href{http://www.ibm.com/developerworks/java/library/j-math2.html}{http://www.ibm.com/developerworks/java/lib\\rary/j-math2.html} accessed on 22/03/2011
\bibitem{13}
''Hadamard Transform Image Coding'', William K. Pratt, Julius Kane, Harry C. Andrews, Proceedings of the IEEE 57 (1), 58-66 (1969)



\end{thebibliography}

\end{document}
